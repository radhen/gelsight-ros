#!/usr/bin/env python3

"""
Plots image gradients from a given CSV file.

This can be used to verify data generated by the 'label_data.py' script.
"""

import gelsight_ros as gsr
import csv
from csv import writer
import cv2
import gelsight_ros as gsr
import math
import numpy as np
import os
import rospy
import matplotlib.pyplot as plt

DEFAULT_FIELD_NAMES = ['img_name', 'R', 'G', 'B', 'x', 'y', 'gx', 'gy']
imw = 120
imh = 160
mpp = 0.00018958889782351692

if __name__ == "__main__":
    rospy.init_node("plot")

    # Retrieve path where dataset is stored
    if not rospy.has_param("~input_path"):
        rospy.signal_shutdown("No input path provided. Please set input_path/.")
    input_path = rospy.get_param("~input_path")
    if input_path[-1] == "/":
        input_path = input_path[:len(input_path)-1]

    # Collect gradient data
    file_labels = {}
    with open(input_path, 'r') as f:
        reader = csv.reader(f)
        for row in reader:
            img_name, R, G, B, x, y, gx, gy = row
            if img_name == "img_name":
                continue

            if img_name not in file_labels:
                file_labels[img_name] = np.zeros((160, 120, 3))

            R = float(R)
            G = float(G)
            B = float(B)
            gx = float(gx)
            gy = float(gy)
            norm = math.sqrt((gx*gx) + (gy*gy)) 
            if norm == 0.0:
                ux = 0.0
                uy = 0.0
            else:
                ux = gx / norm
                uy = gy / norm
            ux = gx
            uy = gy
            file_labels[img_name][int(y), int(x)] = [ux, uy, R + G + B]

    # Collect first image from dataset
    img = list(file_labels.keys())[0]
    X = np.arange(imw)
    Y = np.flip(np.arange(imh))
    U = file_labels[img][:, :, 1]
    V = file_labels[img][:, :, 0]
    C = file_labels[img][:, :, 2]

    # Plot matplotlib quiver
    fig, ax = plt.subplots()
    ax.quiver(X, Y, U, V, C) #, scale=30, width=0.0005)
    plt.show()

    # Plot open3d pointcloud
    vis3d = gsr.gs3drecon.Visualize3D(imw, imh, '', mpp)
    boundary = np.zeros((imh, imw))
    dm = gsr.util.poisson_reconstruct(U, V, boundary)
    dm = np.reshape(dm, (imh, imw))
    vis3d.update(dm)
    cv2.waitKey(100000000)
